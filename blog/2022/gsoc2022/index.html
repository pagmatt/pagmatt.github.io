<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>My GSoC 2022 experience | Matteo Pagin</title> <meta name="author" content="Matteo Pagin"/> <meta name="description" content="Final thoughts on my participation to the 2022 edition of the Google Summer of Code for the ns-3 organization"/> <meta name="keywords" content="pagin-matteo, matteo-pagin, dei, phd, telecom"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/posterior.png"/> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://pagmatt.github.io/blog/2022/gsoc2022/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <d-front-matter> <script async type="text/json">{
      "title": "My GSoC 2022 experience",
      "description": "Final thoughts on my participation to the 2022 edition of the Google Summer of Code for the ns-3 organization",
      "published": "September 19, 2022",
      "authors": [
        {
          "author": "Matteo Pagin",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Università degli studi di Padova",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <body class="fixed-top-nav"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Matteo </span>Pagin</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/contacts/">Contacts</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="post distill"> <d-title> <h1>My GSoC 2022 experience</h1> <p>Final thoughts on my participation to the 2022 edition of the Google Summer of Code for the ns-3 organization</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#goals">Goals</a></div> <div><a href="#results-two-ray-fading-model">Results, Two-Ray fading model</a></div> <ul> <li><a href="#tworayspectrumpropagationlossmodel-implementation">TwoRaySpectrumPropagationLossModel implementation</a></li> <li><a href="#calibration">Calibration</a></li> <li><a href="#testing">Testing</a></li> </ul> <div><a href="#results-38-901-framework-optimizations">Results, 38.901 framework optimizations</a></div> <div><a href="#results-tldr">Results, TLDR</a></div> </nav> </d-contents> <p>During the summer of 2022 I have been participating in the Google Summer of Code initiative, aiming to contribute to the <a href="https://www.nsnam.org/" target="_blank" rel="noopener noreferrer">ns-3 organization</a> with a project titled <em>“A simplified channel and beamforming model for ns-3”</em>. In this blog post I am sharing a final report on the project and my overall experience.</p> <hr> <h2 id="goals">Goals</h2> <p>The overall objective of my proposal was twofold:</p> <ul> <li>To provide ns-3 with a simplified statistical channel model; and</li> <li>to improve the performance of the TR 38.901-based <d-cite key="3GPP38901"></d-cite> framework which is available in ns-3.</li> </ul> <p>My project plan proposed to meet such objectives by performing the following tasks:</p> <ul> <li> <strong>The design of the simplified channel and beamforming models.</strong> This task aims at providing ns-3 with a simplified channel model for the end-to-end performance evaluation of MIMO wireless networks. The approach which I propose is to compute the end-to-end channel gain as the sum of several losses and gains terms which account for the large-scale phenomena such as free-space path loss and shadowing, the small-scale fading (based on the Fluctuating Two Ray (FTR) model <d-cite key="Romero2017"></d-cite>) and the antenna and beamforming gains.</li> <li> <strong>The implementation of the matrix-based channel model optimizations.</strong> This part of the project consists in porting the TR 38.901-based channel and beamforming models to the open-source linear algebra library <a href="https://eigen.tuxfamily.org/index.php?title=Main_Page" target="_blank" rel="noopener noreferrer">Eigen</a>, on top of completing the optimizations proposed in MR 897, which proposes the caching of the cluster-only dependent trigonometric terms to speedup the generation of new channel matrices.</li> <li> <strong>The calibration of the simplified channel model.</strong> This final task aims at calibrating the FTR model with respect to the pre-existing 3GPP TR 38.901 framework of <d-cite key="Zugno2020"></d-cite>.. Additionally, the goal is to first calibrate the latter as well, since it has been previously skipped due to missing functionality.</li> </ul> <p>For additional details, please refer to the <a href="https://drive.google.com/file/d/14NLQcWCLIH8MZ7G5KQGuBFABxtPrylEd/view" target="_blank" rel="noopener noreferrer">complete project proposal</a>.</p> <hr> <h2 id="results-two-ray-fading-model">Results, Two-Ray fading model</h2> <p>The model <strong>aims to provide a performance-oriented alternative to the 3GPP TR 38.901 framework</strong> <d-cite key="3GPP38901"></d-cite> which is implemented in the <code class="language-plaintext highlighter-rouge">ThreeGppSpectrumPropagationLossModel</code> and <code class="language-plaintext highlighter-rouge">ThreeGppChannelModel</code> classes and whose implementation is described in <d-cite key="Zugno2020"></d-cite>. The overall design follows the general approach of <d-cite key="Polese2018"></d-cite>, with aim of providing the means for computing a 3GPP TR 38.901-like end-to-end channel gain by combining several statistical terms. The frequency range of applicability is the same as that of <d-cite key="3GPP38901"></d-cite>, i.e., 0.5 - 100 GHz.</p> <h3 id="tworayspectrumpropagationlossmodel-implementation">TwoRaySpectrumPropagationLossModel implementation</h3> <p>The computation of the channel gain is taken care of by the <code class="language-plaintext highlighter-rouge">TwoRaySpectrumPropagationLossModel</code> class. In particular, the latter samples a statistical term which combines:</p> <ul> <li> <p>The <strong>array and beamforming gain</strong>, computed as outlined in <d-cite key="Rebato2018"></d-cite> using the <code class="language-plaintext highlighter-rouge">CalcBeamformingGain</code> function. This term supports the presence of multiple antenna elements both at the transmitter and at the receiver and arbitrary antenna radiation patterns. Specifically, the array gain is compute as:</p> \[G_{\mathrm{AA}}(\theta, \varphi)=\left|\boldsymbol{a}^{\mathrm{T}}(\theta, \varphi) \boldsymbol{w}\left(\theta_0, \varphi_0\right)\right|^2=\left|\mathrm{AF}_{\mathrm{v}}(\theta, \varphi)\right|^2\left|\mathrm{AF}_{\mathrm{h}}(\theta, \varphi)\right|^2 G(\theta, \varphi),\] <p>where:</p> \[\operatorname{AF}_{\mathrm{v}}(\theta, \varphi)=\frac{1}{\sqrt{N_{\mathrm{v}}}} \sum_{m=0}^{N_{\mathrm{v}}-1} e^{j k d_{\mathrm{v}} m\left(\cos \theta-\cos \theta_0\right)} \\\] <p>and</p> \[\operatorname{AF}_{\mathrm{h}}(\theta, \varphi)=\frac{1}{\sqrt{N_{\mathrm{h}}}} \sum_{n=0}^{N_{\mathrm{h}}-1} e^{j k d_{\mathrm{h}} n\left(\sin \theta \sin \varphi-\sin \theta_0 \sin \varphi_0\right)},\] <p>In turn, \(N_h, N_v\) are the number of horizontal and vertical antenna elements, respectively and \(d_h, d_v\) are the element spacing in the horizontal and vertical direction, respectively.</p> <p>Whenever the link is in NLOS, a penalty factor is introduced, to account for beam misalignment due to the lack of a dominant multipath component <d-cite key="Kulkarni2018"></d-cite>;</p> </li> <li> <p>A <strong>fast fading term</strong>, sampled using the <strong>Fluctuating Two Ray (FTR)</strong> model distribution <d-cite key="Romero2017"></d-cite>. The latter is a fading model which is more general than typical ones, taking into account two dominant specular components and a mixture of scattered paths. As, a consequence it has been shown to provide a better fit to fading phenomena at mmWaves.</p> </li> </ul> <h3 id="calibration">Calibration</h3> <p>The model parameters are automatically picked once the simulation scenario is set, using a lookup table which associates the simulation parameters (such as carrier frequency and LOS condition) to the FTR parameters providing the best fit to the corresponding TR 38.901 channel statistics. As a consequence, <em>this channel model can be used for all the frequencies which are supported by the 38.901 model, i.e., 0.5-100 GHz</em>.<br> The calibration has been done by first obtaining the statistics of the channel gain due to the small-scale fading in the 3GPP model, using an ad hoc simulation script (src/spectrum/examples/three-gpp-two-ray-channel-calibration.cc). Then, this information has been used as a reference to estimate the FTR parameters yielding the closest (in a goodness-of-fit sense) fading realizations, using a custom Python script (src/spectrum/utils/two-ray-to-three-gpp-ch-calibration.py).</p> <p><strong>Note:</strong></p> <ul> <li>To then obtain a full channel model characterization, the model is intended to be used in conjunction of the path loss and shadowing capability provided by the ThreeGppPropagationLossModel class. Indeed, the goal of this model is to provide channel realizations which are as close as possible to ones of <d-cite key="3GPP38901"></d-cite>, but at a fraction of the complexity. Since the path loss and shadowing terms are not computationally demanding anyway, the ones of <d-cite key="Zugno2020"></d-cite> <p>have been kept;</p> </li> <li>Currently, the value of NLOS beamforming factor penalty factor is taken from the preliminary work of <d-cite key="Kulkarni2018"></d-cite> and it is scenario-independent; As future work, the possibility of using scenario-dependent penalty factors will be investigated.</li> </ul> <h3 id="testing">Testing</h3> <p>The test suite <code class="language-plaintext highlighter-rouge">TwoRaySplmTestSuite</code> includes three test cases:</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">FtrFadingModelAverageTest</code>, which checks that the average of the Fluctuating Two Ray (FTR) fading model realizations is consistent with the theoretical value provided in <d-cite key="Romero2017"></d-cite>.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">ArrayResponseTest</code>, which checks that the overall array response at boresight computed by the ù CalcBeamformingGain function coincides with the expected theoretical values.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">OverallGainAverageTest</code>, which checks that the average overall channel gain obtained using the <code class="language-plaintext highlighter-rouge">DoCalcRxPowerSpectralDensity</code> method of the <code class="language-plaintext highlighter-rouge">TwoRaySpectrumPropagationLossModel</code> class is close (it is, after all, a simplified and performance-oriented model) to the one obtained using the <code class="language-plaintext highlighter-rouge">ThreeGppSpectrumPropagationLossModel</code> and <code class="language-plaintext highlighter-rouge">ThreeGppChannelModel</code> classes.</p> </li> </ul> <hr> <h2 id="results-38901-framework-optimizations">Results, 38.901 framework optimizations</h2> <p>For the second part of my project, I introduced support for the open-source linear algebra <a href="https://eigen.tuxfamily.org/index.php?title=Main_Page" target="_blank" rel="noopener noreferrer">Eigen</a>, with the goal of bringing performance improvements to the 3GPP TR 38.901 framework which is currently available in the ns-3 mainline. Moreover, the installation of Eigen is set as optional, and the code runs as usual whenever the library is not installed in the system.</p> <p>The library has been integrated in ns-3 by mimicking the support for other third-party libraries such as SQLite. In particular, the Eigen library is set as an optional dependency in the <code class="language-plaintext highlighter-rouge">build-support/macros-and-definitions.cmake file</code> and its presence in the system is shown to the user by exposing whether it has been found or not int the <code class="language-plaintext highlighter-rouge">build-support/custom-modules/ns3-configtable.cmake</code> file. The linking of the Eigen’s sources with the ns3 source files is taken care of using the <code class="language-plaintext highlighter-rouge">FindEigen3.cmake</code> file provided by the library itself, as suggested in the <a href="https://www.nsnam.org/docs/manual/html/working-with-cmake.html#linking-third-party-libraries-using-cmake-s-find-package" target="_blank" rel="noopener noreferrer">related ns-3 guide</a>.</p> <p>The main design goal has been minimizing the portion of the code which varies based on Eigen’s availability in the system (dictated by the value of the CMake-defined <code class="language-plaintext highlighter-rouge">HAVE_EIGEN3</code> flag). Since most of the needed operators can not be overloaded for STL C++ vectors (for instance, <code class="language-plaintext highlighter-rouge">()</code>), a uniform interface for both Eigen and STL’s based vectors and matrices has been implemented by defining ad-hoc structs with custom operators. In particular, this interface has been implemented for the <code class="language-plaintext highlighter-rouge">PhasedArrayModel::ComplexVector</code> and the <code class="language-plaintext highlighter-rouge">MatrixBasedChannelModel::Complex2DVector</code> data structures, since they are involved in computationally intensive linear algebra operations.</p> <p>The interface has been designed with Eigen’s API in mind, striving to provide the same API also for STL C++ data-structures, whenever Eigen’s is not installed in the system. Specifically, yhe main differences are:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">size ()</code> does not exist for Eigen’s matrices. Instead, the methods <code class="language-plaintext highlighter-rouge">rows ()</code> and <code class="language-plaintext highlighter-rouge">cols ()</code> are to be used to get the respective sizes of a matrix. On the other hand, Eigen’s vectors provide the size ()` method, thus they are aligned with STL’s vectors in this regard.</li> <li> <code class="language-plaintext highlighter-rouge">resize ()</code> takes as inputs both the numbers of rows and columns in the case of Eigen’s matrices. On the other hand, Eigen’s vectors provide a single-argument <code class="language-plaintext highlighter-rouge">resize ()</code> method, thus they are aligned with STL’s vectors in this regard.</li> <li>the elements of Eigen’s matrices are to be accessed using the <code class="language-plaintext highlighter-rouge">()</code> operator, taking as input the row and column indexes of the specific element to be accessed. This is in contrast to the <code class="language-plaintext highlighter-rouge">[]</code> operator provided by STL vectors. On the other hand, Eigen’s vectors provide a single-argument <code class="language-plaintext highlighter-rouge">[]</code> operator, thus they are aligned with STL’s vectors in this regard.</li> </ul> <p>Moreover, this MR includes also the optimizations to the channel matrix generation procedure for the <code class="language-plaintext highlighter-rouge">ThreeGppChannelModel</code> originally presented in <a href="https://gitlab.com/nsnam/ns-3-dev/-/merge_requests/897" target="_blank" rel="noopener noreferrer">MR !897</a>.</p> <hr> <h2 id="results-tldr">Results, TLDR</h2> <p>All the main objectives of the project i.e., the speed-up of the channel matrix generation procedure in the <code class="language-plaintext highlighter-rouge">ThreeGppChannelModel</code> class, the optional support for the Eigen linear algebra library and its use for the spectrum model matrix/vector operations and the design, and the implementation and calibration of the simplified 3GPP 39.901-based channel model have been met. Due to time constraints, the 3GPP TR 38.901 calibration was left as future work.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2022 Matteo Pagin. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. </div> </footer> <d-bibliography src="/assets/bibliography/gsoc.bib"></d-bibliography> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> </body> </html>